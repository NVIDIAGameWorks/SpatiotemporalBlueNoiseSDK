# SpatiotemporalBlueNoiseSDK

This SDK contains both **S**patio**T**emporal **B**lue **N**oise textures as well as the sample code that generates it.

## Pregenerated textures

`Assets/STBN.zip` contains pregenerated spatiotemporal blue noise textures of various types.

## Sample Code

This repo also contains the sample code to generate spatiotemporal blue noise textures of various types and goes along with these blog posts:

https://developer.nvidia.com/blog/rendering-in-real-time-with-spatiotemporal-blue-noise-textures-part-1/

https://developer.nvidia.com/blog/rendering-in-real-time-with-spatiotemporal-blue-noise-textures-part-2/

As well as this EGSR 2022 paper:

https://diglib.eg.org/handle/10.2312/sr20221161

And this arxiv paper:

https://arxiv.org/abs/2112.09629

## Build Instructions

1. Download the CMake GUI

2. Set the source code directory to this directory (`C:/path/to/repo/SpatiotemporalBlueNoiseSDK`)

3. Set the build directory to `C:/path/to/repo/SpatiotemporalBlueNoiseSDK/build`.

4. Click Configure. Agree to create the `C:/path/to/repo/SpatiotemporalBlueNoiseSDK/build` directory if it does not exist.

5. Select `x64` as the Optional platform for generator

6. Click Generate

7. Open `C:/path/to/repo/SpatiotemporalBlueNoiseSDK/build/STBN.sln`

8. Build the `Release` configuration. (The `Debug` configuration runs very slowly.)

## ScalarApp Run Instructions

ScalarApp generates 1D noise using the void and cluster algorithm. It comes with two implementations, a slow reference one and a "slice cache" optimized one. The reference implementation is used to ensure correctness in the ScalarTest project. The slice cache optimized implementation runs ~60x faster than the reference implementation and produces the same output as the reference, so you should always use it.

## VectorApp Run Instructions

VectorApp generates 1D, 2D, or 3D noise depending on the cmd args. VectorApp uses simulated annealing, which is less effective than void and cluster.

The initial noise pattern may be generated by using uniform noise over the unit cuboid, normalized uniform noise over the unit spheroid, and optionally cosine weighted hemisphere noise for 3D noise.

Distances between pixels is calculated using either the L1, L2, LInfinity metric, with 3D data having the additional option of using the negative dot product. (L1, L2, and LInfinity metrics all reduce to the absolute value metric for 1D noise.)